(()=>{var __webpack_modules__={158:()=>{eval('function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n// worker eventlistener. Do not change this.\n//#region\nself.addEventListener("message", function (e) {\n  self.postMessage(solve(e.data));\n}); //#endregion\n// your code goes below this line\n// ----------------------------------------------------------\n// Author: Javid Bunyadzade (https://github.com/Grulice)\n\nfunction solve(mazeInfo) {\n  // main solve function\n  // â€‹\n  // mazeInfo is a JS object and it contains the following info:\n  // dimensions: Object { rowNumber: 278, colNumber: 165 } -- the number of rows and cols\n  // end: Array [ 180, 79 ] -- the coordinates of the end\n  // start: Array [ 142, 79 ] -- the coordinates of the start\n  // walls: [[0,1], [0,2]] -- array of coordinates of the walls\n  // this function must return an array of coordinates of the path (similar to the walls)\n  // Happy pathfinding! :)\n  return solveAStar(mazeInfo);\n}\n\nvar nodeTypes = {\n  EMPTY: 0,\n  WALL: 1,\n  START: 2,\n  END: 3\n};\n\nfunction solveAStar(mazeInfo) {\n  var graph = initiateGraph(mazeInfo); // initialize the notTested list\n\n  graph.startNode.localScore = 0;\n  graph.startNode.globalScore = heuristic(graph.startNode, graph.endNode);\n  var notTested = [graph.startNode];\n  var currentNode = graph.startNode; // continue while there are unexplored nodes OR we\'ve hit the end\n  // this does not guarantee the shortest path, but it\'s a performance improvement\n  // and you\'ll most likely be on the shortest path. If you want to explore all\n  // nodes and 100% get the shortest path - remove the currentNode != graph.endNode condition\n\n  while (notTested.length > 0 && currentNode != graph.endNode) {\n    // sort the array by the global heuristic (check nodes that are physically\n    // closer to the end first)\n    notTested.sort(function (nodeA, nodeB) {\n      return nodeA.globalScore > nodeB.globalScore;\n    }); // shift the notTested and test that node. We won\'t visit a node\n    // more than once\n\n    currentNode = notTested.shift();\n    currentNode.visited = true;\n\n    var _iterator = _createForOfIteratorHelper(getNodeNeighbors(currentNode, graph)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var neighbor = _step.value;\n\n        // only add the neighbor node if it hasn\'t been visited, it\'s not a wall\n        // or if it is not already in the list\n        if (!neighbor.visited && neighbor.type !== nodeTypes.WALL && !notTested.includes(neighbor)) {\n          notTested.push(neighbor);\n        } // calculate the potential local score. The actual algo\n        // should compute the edge\'s weight between 2 nodes, but we can optimize\n        // because our graph is a grid and all edge weights are 1\n\n\n        curLocalScore = currentNode.localScore + 1;\n\n        if (neighbor.localScore > curLocalScore) {\n          // update the neighbor if the current computed local score is lower\n          // than the neighbors own local score\n          neighbor.parent = currentNode;\n          neighbor.localScore = curLocalScore; // the global score is calculated from how difficult it is to get to this cell so far PLUS\n          // the direct distance to the end, so that there\'s bias towards the nodes that are physically closer\n          // to the end\n\n          neighbor.globalScore = curLocalScore + heuristic(neighbor, graph.endNode);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } // backtrack starting from the end\n\n\n  currentNode = graph.endNode;\n  var finalPath = [];\n\n  while (currentNode.parent) {\n    finalPath.push([currentNode.row, currentNode.col]);\n    currentNode = currentNode.parent;\n  }\n\n  return finalPath;\n}\n\nfunction initiateGraph(mazeInfo) {\n  var resultGraph = [];\n  var rowsN = mazeInfo.dimensions.rowNumber;\n  var colsN = mazeInfo.dimensions.colNumber;\n  var startNode = null,\n      endNode = null;\n\n  var _loop = function _loop(curRowNum) {\n    var curRow = [];\n\n    var _loop2 = function _loop2(curColNum) {\n      var newNode = createNode(curRowNum, curColNum);\n\n      if (curRowNum === mazeInfo.start[0] && curColNum === mazeInfo.start[1]) {\n        newNode.type = nodeTypes.START;\n        startNode = newNode;\n      } else if (curRowNum === mazeInfo.end[0] && curColNum === mazeInfo.end[1]) {\n        newNode.type = nodeTypes.END;\n        endNode = newNode;\n      } else if (mazeInfo.walls.find(function (wall) {\n        return wall[0] === curRowNum && wall[1] === curColNum;\n      })) {\n        newNode.type = nodeTypes.WALL;\n      } else {\n        newNode.type = nodeTypes.EMPTY;\n      }\n\n      curRow.push(newNode);\n    };\n\n    for (var curColNum = 0; curColNum < colsN; curColNum++) {\n      _loop2(curColNum);\n    }\n\n    resultGraph.push(curRow);\n  };\n\n  for (var curRowNum = 0; curRowNum < rowsN; curRowNum++) {\n    _loop(curRowNum);\n  }\n\n  return {\n    nodes: resultGraph,\n    startNode: startNode,\n    endNode: endNode\n  };\n}\n\nfunction createNode(rowNum, colNum) {\n  return {\n    type: nodeTypes.EMPTY,\n    visited: false,\n    globalScore: Number.POSITIVE_INFINITY,\n    localScore: Number.POSITIVE_INFINITY,\n    row: rowNum,\n    col: colNum,\n    parent: null\n  };\n}\n\nfunction heuristic(nodeA, nodeB) {\n  return distance(nodeA, nodeB);\n}\n\nfunction distance(nodeA, nodeB) {\n  // find distance using Pythagoras\' theorem\n  var sideA = nodeA.row - nodeB.row + 1;\n  var sideB = nodeA.col - nodeB.col + 1;\n  return Math.sqrt(Math.pow(sideA, 2) + Math.pow(sideB, 2));\n}\n\nfunction getNodeNeighbors(node, graph) {\n  var neighbors = [];\n  var offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\n  for (var _i = 0, _offsets = offsets; _i < _offsets.length; _i++) {\n    var offset = _offsets[_i];\n    var targetCoordRow = node.row + offset[0];\n    var targetCoordCol = node.col + offset[1];\n\n    if (targetCoordRow >= 0 && targetCoordRow < graph.nodes.length && targetCoordCol >= 0 && targetCoordCol < graph.nodes[0].length) {\n      neighbors.push(graph.nodes[targetCoordRow][targetCoordCol]);\n    }\n  }\n\n  return neighbors;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc19tYXplZnJhbWV3b3JrLy4vc3JjL2FsZ29zL3NjcmlwdHMvYXN0YXIuanM/YjcwZiJdLCJuYW1lcyI6WyJzZWxmIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwb3N0TWVzc2FnZSIsInNvbHZlIiwiZGF0YSIsIm1hemVJbmZvIiwic29sdmVBU3RhciIsIm5vZGVUeXBlcyIsIkVNUFRZIiwiV0FMTCIsIlNUQVJUIiwiRU5EIiwiZ3JhcGgiLCJpbml0aWF0ZUdyYXBoIiwic3RhcnROb2RlIiwibG9jYWxTY29yZSIsImdsb2JhbFNjb3JlIiwiaGV1cmlzdGljIiwiZW5kTm9kZSIsIm5vdFRlc3RlZCIsImN1cnJlbnROb2RlIiwibGVuZ3RoIiwic29ydCIsIm5vZGVBIiwibm9kZUIiLCJzaGlmdCIsInZpc2l0ZWQiLCJnZXROb2RlTmVpZ2hib3JzIiwibmVpZ2hib3IiLCJ0eXBlIiwiaW5jbHVkZXMiLCJwdXNoIiwiY3VyTG9jYWxTY29yZSIsInBhcmVudCIsImZpbmFsUGF0aCIsInJvdyIsImNvbCIsInJlc3VsdEdyYXBoIiwicm93c04iLCJkaW1lbnNpb25zIiwicm93TnVtYmVyIiwiY29sc04iLCJjb2xOdW1iZXIiLCJjdXJSb3dOdW0iLCJjdXJSb3ciLCJjdXJDb2xOdW0iLCJuZXdOb2RlIiwiY3JlYXRlTm9kZSIsInN0YXJ0IiwiZW5kIiwid2FsbHMiLCJmaW5kIiwid2FsbCIsIm5vZGVzIiwicm93TnVtIiwiY29sTnVtIiwiTnVtYmVyIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJkaXN0YW5jZSIsInNpZGVBIiwic2lkZUIiLCJNYXRoIiwic3FydCIsIm5vZGUiLCJuZWlnaGJvcnMiLCJvZmZzZXRzIiwib2Zmc2V0IiwidGFyZ2V0Q29vcmRSb3ciLCJ0YXJnZXRDb29yZENvbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBQSxJQUFJLENBQUNDLGdCQUFMLENBQXNCLFNBQXRCLEVBQWlDLFVBQUNDLENBQUQsRUFBTztB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UUFBSUUsY0FBYyxHQUFHTCxJQUFJLENBQUMzQixHQUFMLEdBQVc4QixNQUFNLENBQUMsQ0FBRCxDQUF0Qzs7QUFDQSxRQUNJQyxjQUFjLElBQUksQ0FBbEIsSUFDQUEsY0FBYyxHQUFHdkQsS0FBSyxDQUFDeUMsS0FBTixDQUFZaEMsTUFEN0IsSUFFQStDLGNBQWMsSUFBSSxDQUZsQixJQUdBQSxjQUFjLEdBQUd4RCxLQUFLLENBQUN5QyxLQUFOLENBQVksQ0FBWixFQUFlaEMsTUFKcEMsRUFLRTtBQUNFMkMsTUFBQUEsU0FBUyxDQUFDakMsSUFBVixDQUFlbkIsS0FBSyxDQUFDeUMsS0FBTixDQUFZYyxjQUFaLEVBQTRCQyxjQUE1QixDQUFmO0FBQ0g7QUFDSjs7QUFFRCxTQUFPSixTQUFQO0FBQ0giLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3b3JrZXIgZXZlbnRsaXN0ZW5lci4gRG8gbm90IGNoYW5nZSB0aGlzLlxuLy8jcmVnaW9uXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZShzb2x2ZShlLmRhdGEpKTtcbn0pO1xuLy8jZW5kcmVnaW9uXG5cbi8vIHlvdXIgY29kZSBnb2VzIGJlbG93IHRoaXMgbGluZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQXV0aG9yOiBKYXZpZCBCdW55YWR6YWRlIChodHRwczovL2dpdGh1Yi5jb20vR3J1bGljZSlcblxuZnVuY3Rpb24gc29sdmUobWF6ZUluZm8pIHtcbiAgICAvLyBtYWluIHNvbHZlIGZ1bmN0aW9uXG4gICAgLy8g4oCLXG4gICAgLy8gbWF6ZUluZm8gaXMgYSBKUyBvYmplY3QgYW5kIGl0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mbzpcbiAgICAvLyBkaW1lbnNpb25zOiBPYmplY3QgeyByb3dOdW1iZXI6IDI3OCwgY29sTnVtYmVyOiAxNjUgfSAtLSB0aGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHNcbiAgICAvLyBlbmQ6IEFycmF5IFsgMTgwLCA3OSBdIC0tIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZW5kXG4gICAgLy8gc3RhcnQ6IEFycmF5IFsgMTQyLCA3OSBdIC0tIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgc3RhcnRcbiAgICAvLyB3YWxsczogW1swLDFdLCBbMCwyXV0gLS0gYXJyYXkgb2YgY29vcmRpbmF0ZXMgb2YgdGhlIHdhbGxzXG5cbiAgICAvLyB0aGlzIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXRoIChzaW1pbGFyIHRvIHRoZSB3YWxscylcbiAgICAvLyBIYXBweSBwYXRoZmluZGluZyEgOilcblxuICAgIHJldHVybiBzb2x2ZUFTdGFyKG1hemVJbmZvKTtcbn1cblxuY29uc3Qgbm9kZVR5cGVzID0ge1xuICAgIEVNUFRZOiAwLFxuICAgIFdBTEw6IDEsXG4gICAgU1RBUlQ6IDIsXG4gICAgRU5EOiAzLFxufTtcblxuZnVuY3Rpb24gc29sdmVBU3RhcihtYXplSW5mbykge1xuICAgIGxldCBncmFwaCA9IGluaXRpYXRlR3JhcGgobWF6ZUluZm8pO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgbm90VGVzdGVkIGxpc3RcbiAgICBncmFwaC5zdGFydE5vZGUubG9jYWxTY29yZSA9IDA7XG4gICAgZ3JhcGguc3RhcnROb2RlLmdsb2JhbFNjb3JlID0gaGV1cmlzdGljKGdyYXBoLnN0YXJ0Tm9kZSwgZ3JhcGguZW5kTm9kZSk7XG4gICAgbGV0IG5vdFRlc3RlZCA9IFtncmFwaC5zdGFydE5vZGVdO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IGdyYXBoLnN0YXJ0Tm9kZTtcblxuICAgIC8vIGNvbnRpbnVlIHdoaWxlIHRoZXJlIGFyZSB1bmV4cGxvcmVkIG5vZGVzIE9SIHdlJ3ZlIGhpdCB0aGUgZW5kXG4gICAgLy8gdGhpcyBkb2VzIG5vdCBndWFyYW50ZWUgdGhlIHNob3J0ZXN0IHBhdGgsIGJ1dCBpdCdzIGEgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRcbiAgICAvLyBhbmQgeW91J2xsIG1vc3QgbGlrZWx5IGJlIG9uIHRoZSBzaG9ydGVzdCBwYXRoLiBJZiB5b3Ugd2FudCB0byBleHBsb3JlIGFsbFxuICAgIC8vIG5vZGVzIGFuZCAxMDAlIGdldCB0aGUgc2hvcnRlc3QgcGF0aCAtIHJlbW92ZSB0aGUgY3VycmVudE5vZGUgIT0gZ3JhcGguZW5kTm9kZSBjb25kaXRpb25cbiAgICB3aGlsZSAobm90VGVzdGVkLmxlbmd0aCA+IDAgJiYgY3VycmVudE5vZGUgIT0gZ3JhcGguZW5kTm9kZSkge1xuICAgICAgICAvLyBzb3J0IHRoZSBhcnJheSBieSB0aGUgZ2xvYmFsIGhldXJpc3RpYyAoY2hlY2sgbm9kZXMgdGhhdCBhcmUgcGh5c2ljYWxseVxuICAgICAgICAvLyBjbG9zZXIgdG8gdGhlIGVuZCBmaXJzdClcbiAgICAgICAgbm90VGVzdGVkLnNvcnQoKG5vZGVBLCBub2RlQikgPT4gbm9kZUEuZ2xvYmFsU2NvcmUgPiBub2RlQi5nbG9iYWxTY29yZSk7XG5cbiAgICAgICAgLy8gc2hpZnQgdGhlIG5vdFRlc3RlZCBhbmQgdGVzdCB0aGF0IG5vZGUuIFdlIHdvbid0IHZpc2l0IGEgbm9kZVxuICAgICAgICAvLyBtb3JlIHRoYW4gb25jZVxuICAgICAgICBjdXJyZW50Tm9kZSA9IG5vdFRlc3RlZC5zaGlmdCgpO1xuICAgICAgICBjdXJyZW50Tm9kZS52aXNpdGVkID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGxldCBuZWlnaGJvciBvZiBnZXROb2RlTmVpZ2hib3JzKGN1cnJlbnROb2RlLCBncmFwaCkpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRoZSBuZWlnaGJvciBub2RlIGlmIGl0IGhhc24ndCBiZWVuIHZpc2l0ZWQsIGl0J3Mgbm90IGEgd2FsbFxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgaXMgbm90IGFscmVhZHkgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhbmVpZ2hib3IudmlzaXRlZCAmJlxuICAgICAgICAgICAgICAgIG5laWdoYm9yLnR5cGUgIT09IG5vZGVUeXBlcy5XQUxMICYmXG4gICAgICAgICAgICAgICAgIW5vdFRlc3RlZC5pbmNsdWRlcyhuZWlnaGJvcilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG5vdFRlc3RlZC5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb3RlbnRpYWwgbG9jYWwgc2NvcmUuIFRoZSBhY3R1YWwgYWxnb1xuICAgICAgICAgICAgLy8gc2hvdWxkIGNvbXB1dGUgdGhlIGVkZ2UncyB3ZWlnaHQgYmV0d2VlbiAyIG5vZGVzLCBidXQgd2UgY2FuIG9wdGltaXplXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG91ciBncmFwaCBpcyBhIGdyaWQgYW5kIGFsbCBlZGdlIHdlaWdodHMgYXJlIDFcbiAgICAgICAgICAgIGN1ckxvY2FsU2NvcmUgPSBjdXJyZW50Tm9kZS5sb2NhbFNjb3JlICsgMTtcbiAgICAgICAgICAgIGlmIChuZWlnaGJvci5sb2NhbFNjb3JlID4gY3VyTG9jYWxTY29yZSkge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbmVpZ2hib3IgaWYgdGhlIGN1cnJlbnQgY29tcHV0ZWQgbG9jYWwgc2NvcmUgaXMgbG93ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGFuIHRoZSBuZWlnaGJvcnMgb3duIGxvY2FsIHNjb3JlXG4gICAgICAgICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3IubG9jYWxTY29yZSA9IGN1ckxvY2FsU2NvcmU7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGdsb2JhbCBzY29yZSBpcyBjYWxjdWxhdGVkIGZyb20gaG93IGRpZmZpY3VsdCBpdCBpcyB0byBnZXQgdG8gdGhpcyBjZWxsIHNvIGZhciBQTFVTXG4gICAgICAgICAgICAgICAgLy8gdGhlIGRpcmVjdCBkaXN0YW5jZSB0byB0aGUgZW5kLCBzbyB0aGF0IHRoZXJlJ3MgYmlhcyB0b3dhcmRzIHRoZSBub2RlcyB0aGF0IGFyZSBwaHlzaWNhbGx5IGNsb3NlclxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5nbG9iYWxTY29yZSA9XG4gICAgICAgICAgICAgICAgICAgIGN1ckxvY2FsU2NvcmUgKyBoZXVyaXN0aWMobmVpZ2hib3IsIGdyYXBoLmVuZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmFja3RyYWNrIHN0YXJ0aW5nIGZyb20gdGhlIGVuZFxuICAgIGN1cnJlbnROb2RlID0gZ3JhcGguZW5kTm9kZTtcbiAgICBsZXQgZmluYWxQYXRoID0gW107XG4gICAgd2hpbGUgKGN1cnJlbnROb2RlLnBhcmVudCkge1xuICAgICAgICBmaW5hbFBhdGgucHVzaChbY3VycmVudE5vZGUucm93LCBjdXJyZW50Tm9kZS5jb2xdKTtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbFBhdGg7XG59XG5cbmZ1bmN0aW9uIGluaXRpYXRlR3JhcGgobWF6ZUluZm8pIHtcbiAgICBsZXQgcmVzdWx0R3JhcGggPSBbXTtcbiAgICBjb25zdCByb3dzTiA9IG1hemVJbmZvLmRpbWVuc2lvbnMucm93TnVtYmVyO1xuICAgIGNvbnN0IGNvbHNOID0gbWF6ZUluZm8uZGltZW5zaW9ucy5jb2xOdW1iZXI7XG4gICAgbGV0IHN0YXJ0Tm9kZSA9IG51bGwsXG4gICAgICAgIGVuZE5vZGUgPSBudWxsO1xuICAgIGZvciAobGV0IGN1clJvd051bSA9IDA7IGN1clJvd051bSA8IHJvd3NOOyBjdXJSb3dOdW0rKykge1xuICAgICAgICBsZXQgY3VyUm93ID0gW107XG4gICAgICAgIGZvciAobGV0IGN1ckNvbE51bSA9IDA7IGN1ckNvbE51bSA8IGNvbHNOOyBjdXJDb2xOdW0rKykge1xuICAgICAgICAgICAgbGV0IG5ld05vZGUgPSBjcmVhdGVOb2RlKGN1clJvd051bSwgY3VyQ29sTnVtKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGN1clJvd051bSA9PT0gbWF6ZUluZm8uc3RhcnRbMF0gJiZcbiAgICAgICAgICAgICAgICBjdXJDb2xOdW0gPT09IG1hemVJbmZvLnN0YXJ0WzFdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLnR5cGUgPSBub2RlVHlwZXMuU1RBUlQ7XG4gICAgICAgICAgICAgICAgc3RhcnROb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgY3VyUm93TnVtID09PSBtYXplSW5mby5lbmRbMF0gJiZcbiAgICAgICAgICAgICAgICBjdXJDb2xOdW0gPT09IG1hemVJbmZvLmVuZFsxXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS50eXBlID0gbm9kZVR5cGVzLkVORDtcbiAgICAgICAgICAgICAgICBlbmROb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgbWF6ZUluZm8ud2FsbHMuZmluZChcbiAgICAgICAgICAgICAgICAgICAgKHdhbGwpID0+IHdhbGxbMF0gPT09IGN1clJvd051bSAmJiB3YWxsWzFdID09PSBjdXJDb2xOdW1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLnR5cGUgPSBub2RlVHlwZXMuV0FMTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS50eXBlID0gbm9kZVR5cGVzLkVNUFRZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJSb3cucHVzaChuZXdOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRHcmFwaC5wdXNoKGN1clJvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbm9kZXM6IHJlc3VsdEdyYXBoLCBzdGFydE5vZGU6IHN0YXJ0Tm9kZSwgZW5kTm9kZTogZW5kTm9kZSB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKHJvd051bSwgY29sTnVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogbm9kZVR5cGVzLkVNUFRZLFxuICAgICAgICB2aXNpdGVkOiBmYWxzZSxcbiAgICAgICAgZ2xvYmFsU2NvcmU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgbG9jYWxTY29yZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICByb3c6IHJvd051bSxcbiAgICAgICAgY29sOiBjb2xOdW0sXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoZXVyaXN0aWMobm9kZUEsIG5vZGVCKSB7XG4gICAgcmV0dXJuIGRpc3RhbmNlKG5vZGVBLCBub2RlQik7XG59XG5cbmZ1bmN0aW9uIGRpc3RhbmNlKG5vZGVBLCBub2RlQikge1xuICAgIC8vIGZpbmQgZGlzdGFuY2UgdXNpbmcgUHl0aGFnb3JhcycgdGhlb3JlbVxuICAgIGxldCBzaWRlQSA9IG5vZGVBLnJvdyAtIG5vZGVCLnJvdyArIDE7XG4gICAgbGV0IHNpZGVCID0gbm9kZUEuY29sIC0gbm9kZUIuY29sICsgMTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHNpZGVBICoqIDIgKyBzaWRlQiAqKiAyKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZU5laWdoYm9ycyhub2RlLCBncmFwaCkge1xuICAgIGxldCBuZWlnaGJvcnMgPSBbXTtcbiAgICBsZXQgb2Zmc2V0cyA9IFtcbiAgICAgICAgWy0xLCAwXSxcbiAgICAgICAgWzEsIDBdLFxuICAgICAgICBbMCwgLTFdLFxuICAgICAgICBbMCwgMV0sXG4gICAgXTtcblxuICAgIGZvciAobGV0IG9mZnNldCBvZiBvZmZzZXRzKSB7XG4gICAgICAgIGxldCB0YXJnZXRDb29yZFJvdyA9IG5vZGUucm93ICsgb2Zmc2V0WzBdO1xuICAgICAgICBsZXQgdGFyZ2V0Q29vcmRDb2wgPSBub2RlLmNvbCArIG9mZnNldFsxXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGFyZ2V0Q29vcmRSb3cgPj0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Q29vcmRSb3cgPCBncmFwaC5ub2Rlcy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRhcmdldENvb3JkQ29sID49IDAgJiZcbiAgICAgICAgICAgIHRhcmdldENvb3JkQ29sIDwgZ3JhcGgubm9kZXNbMF0ubGVuZ3RoXG4gICAgICAgICkge1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2goZ3JhcGgubm9kZXNbdGFyZ2V0Q29vcmRSb3ddW3RhcmdldENvb3JkQ29sXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVpZ2hib3JzO1xufVxuIl0sImZpbGUiOiIxNTguanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///158\n')}},__webpack_exports__={};__webpack_modules__[158]()})();