(()=>{"use strict";var __webpack_modules__={367:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval('\n;// CONCATENATED MODULE: ./src/utils.js\nfunction addMouseListenersToCell(htmlCell, maze) {\n  // press-drag listeners\n  htmlCell.addEventListener("mouseover", function (e) {\n    e.preventDefault();\n    var curpos = [this.mazeRow, this.mazeCol];\n\n    if (e.buttons === 1) {\n      if (e.shiftKey) {\n        maze.drawStart(curpos);\n      } else if (e.ctrlKey || e.metaKey) {\n        maze.drawEnd(curpos);\n      } else {\n        maze.drawWall(curpos);\n      }\n    } else if (e.buttons === 2) {\n      maze.eraseCell(curpos);\n    }\n  }); // For some reason, single clicks over cells are not handled by events above,\n  // so we have to write them out separately\n\n  htmlCell.addEventListener("click", function (e) {\n    e.preventDefault();\n    var curpos = [this.mazeRow, this.mazeCol];\n\n    if (e.shiftKey) {\n      maze.drawStart(curpos);\n    } else if (e.ctrlKey || e.metaKey) {\n      maze.drawEnd(curpos);\n    } else {\n      maze.drawWall(curpos);\n    }\n  });\n  htmlCell.addEventListener("contextmenu", function (e) {\n    e.preventDefault();\n    var curpos = [this.mazeRow, this.mazeCol];\n    maze.eraseCell(curpos);\n  });\n}\nfunction getCellDimensions(colsNum) {\n  return (window.innerHeight - 25) / colsNum;\n}\nfunction removeAllChildren(element) {\n  while (element.firstChild) {\n    element.removeChild(element.firstChild);\n  }\n}\n;// CONCATENATED MODULE: ./src/algos/index.js\nvar workers = {\n  astar: {\n    worker: new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(158), __webpack_require__.b)),\n    displayName: "A*"\n  },\n  mrgd: {\n    worker: new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(705), __webpack_require__.b)),\n    displayName: "MRGD"\n  },\n  wave_propagation: {\n    worker: new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(650), __webpack_require__.b)),\n    displayName: "Wave Propagation"\n  }\n};\n;// CONCATENATED MODULE: ./src/consts.js\nvar CELL_TYPES = {\n  EMPTY: 0,\n  WALL: 1,\n  START: 2,\n  END: 3,\n  PATH: 4\n};\nvar CELL_TYPE_STYLES = {\n  0: "cell-empty",\n  // empty\n  1: "cell-wall",\n  // wall\n  2: "cell-start",\n  // start\n  3: "cell-end",\n  // end\n  4: "cell-path" // path\n\n};\nvar RANDOM_MAZE_API_BASEURL = "https://api.noopschallenge.com/mazebot/";\n;// CONCATENATED MODULE: ./src/index.js\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\nHTMLTableCellElement.prototype.cellType = CELL_TYPES.EMPTY;\n\nHTMLTableCellElement.prototype.changeCellTypeTo = function (newType) {\n  this.cellType = newType;\n  this.className = CELL_TYPE_STYLES[this.cellType];\n};\n\nHTMLTableCellElement.prototype.mazeRow = 0;\nHTMLTableCellElement.prototype.mazeCol = 0;\nvar mainMazeTbl = document.querySelector("#maze-table");\nvar mazeContainer = document.querySelector(".maze-container");\nmainMazeTbl.addEventListener("dragstart", function (e) {\n  return e.preventDefault();\n});\nvar dimensionElems = {\n  rowInput: document.querySelector("#input-dims-rows"),\n  colInput: document.querySelector("#input-dims-cols"),\n  goButton: document.querySelector("#draw-maze-button")\n};\nvar randomMazeElems = {\n  minSizeSelect: document.querySelector("#rand-size-select-min"),\n  maxSizeSelect: document.querySelector("#rand-size-select-max"),\n  goButton: document.querySelector("#rand-get-maze")\n};\nvar algoSelectElems = {\n  algoSelect: document.querySelector("#algo-select"),\n  goButton: document.querySelector("#find-path-button")\n};\nvar pathInfoElems = {\n  errorLabel: document.querySelector("#error-label"),\n  pathLenCaption: document.querySelector("#path-length"),\n  execTimeCaption: document.querySelector("#exec-time")\n};\nvar loadingPlaque = document.querySelector("#loading-plaque"); // button eventlisteners\n\ndimensionElems.goButton.addEventListener("click", handleCreateMaze); // Main program\n\nvar maze;\nhandleCreateMaze();\nObject.entries(workers).forEach(function (entry) {\n  var _entry = _slicedToArray(entry, 2),\n      key = _entry[0],\n      workerInfo = _entry[1];\n\n  var workerOption = document.createElement("option");\n  workerOption.value = key;\n  workerOption.innerText = workerInfo.displayName;\n  algoSelectElems.algoSelect.append(workerOption);\n});\n\nfunction handleCreateMaze() {\n  var rowsNum = Number(dimensionElems.rowInput.value);\n  var colsNum = Number(dimensionElems.colInput.value);\n  createMaze(rowsNum, colsNum);\n}\n\nfunction createMaze(rowsNum, colsNum) {\n  maze = resetMaze();\n  removeAllChildren(mainMazeTbl);\n  maze.dimensions.rowNumber = rowsNum;\n  maze.dimensions.colNumber = colsNum;\n  var cellDims = getCellDimensions(colsNum);\n\n  for (var rowNumber = 0; rowNumber < rowsNum; rowNumber++) {\n    var curRow = [];\n    var htmlRow = mainMazeTbl.insertRow(rowNumber);\n\n    for (var colNumber = 0; colNumber < colsNum; colNumber++) {\n      // create an HTML cell\n      var curCell = htmlRow.insertCell(colNumber);\n      curCell.mazeRow = rowNumber;\n      curCell.mazeCol = colNumber;\n      curCell.style.height = cellDims + "px";\n      curCell.style.width = cellDims + "px";\n      addMouseListenersToCell(curCell, maze);\n      curRow.push(curCell);\n    }\n\n    maze.cells.push(curRow);\n  }\n}\n\nfunction resetMaze() {\n  return {\n    dimensions: {\n      rowNumber: 0,\n      colNumber: 0\n    },\n    cells: [],\n    walls: [],\n    path: [],\n    startCell: null,\n    endCell: null,\n    drawPath: function drawPath(pathArray) {\n      this.clearPath();\n\n      var _iterator = _createForOfIteratorHelper(pathArray),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var step = _step.value;\n          var targetCell = this.cells[step[0]][step[1]];\n\n          if (targetCell.cellType === CELL_TYPES.EMPTY) {\n            targetCell.changeCellTypeTo(CELL_TYPES.PATH);\n            this.path.push(targetCell);\n          } else {\n            console.warn("Skipping path at ".concat(step[0], ", ").concat(step[1], " because it\'s not an empty cell."));\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    },\n    clearPath: function clearPath() {\n      var shifted = this.path.shift();\n\n      while (shifted) {\n        shifted.changeCellTypeTo(CELL_TYPES.EMPTY);\n        shifted = this.path.shift();\n      }\n    },\n    drawWall: function drawWall(pos) {\n      var targetCell = this.cells[pos[0]][pos[1]];\n\n      if (targetCell.cellType === CELL_TYPES.START) {\n        this.startCell = null;\n      }\n\n      if (targetCell.cellType === CELL_TYPES.END) {\n        this.endCell = null;\n      }\n\n      if (targetCell.cellType === CELL_TYPES.PATH) {\n        this.path = this.path.filter(function (pathCell) {\n          return !(pathCell.mazeRow === targetCell.mazeRow && pathCell.mazeCol === targetCell.mazeCol);\n        });\n      }\n\n      targetCell.changeCellTypeTo(CELL_TYPES.WALL);\n      this.walls.push([targetCell.mazeRow, targetCell.mazeCol]);\n    },\n    drawStart: function drawStart(pos) {\n      var targetCell = this.cells[pos[0]][pos[1]];\n\n      if (this.startCell) {\n        this.startCell.changeCellTypeTo(CELL_TYPES.EMPTY);\n      }\n\n      if (targetCell !== null) targetCell.changeCellTypeTo(CELL_TYPES.START);\n      this.startCell = targetCell;\n    },\n    drawEnd: function drawEnd(pos) {\n      var targetCell = this.cells[pos[0]][pos[1]];\n\n      if (this.endCell) {\n        this.endCell.changeCellTypeTo(CELL_TYPES.EMPTY);\n      }\n\n      if (targetCell !== null) targetCell.changeCellTypeTo(CELL_TYPES.END);\n      this.endCell = targetCell;\n    },\n    eraseCell: function eraseCell(pos) {\n      var targetCell = this.cells[pos[0]][pos[1]];\n\n      if (targetCell.cellType !== CELL_TYPES.EMPTY) {\n        if (targetCell.cellType === CELL_TYPES.START) {\n          this.startCell = null;\n        }\n\n        if (targetCell.cellType === CELL_TYPES.END) {\n          this.endCell = null;\n        }\n\n        targetCell.changeCellTypeTo(CELL_TYPES.EMPTY);\n        maze.walls = maze.walls.filter(function (cell) {\n          return !(cell[0] === targetCell.mazeRow && cell[1] === targetCell.mazeCol);\n        });\n      }\n    }\n  };\n} //#region random maze logic\n\n\nrandomMazeElems.goButton.addEventListener("click", handleRandomMaze);\n\nfunction handleRandomMaze() {\n  var minSize = Number(randomMazeElems.minSizeSelect.value);\n  var maxSize = Number(randomMazeElems.maxSizeSelect.value);\n  if (maxSize < minSize) maxSize = minSize;\n  drawRandomMaze(minSize, maxSize);\n}\n\nfunction drawRandomMaze(_x, _x2) {\n  return _drawRandomMaze.apply(this, arguments);\n} //#endregion\n// pathfinding algorithms connection logic\n\n\nfunction _drawRandomMaze() {\n  _drawRandomMaze = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(minSize, maxSize) {\n    var APIresponse, unparsed, parsed, dims, startpos, endpos, mazeMap, rowNum, row, colNum, cell;\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            loadingPlaque.classList.remove("invisible");\n            APIresponse = fetch(RANDOM_MAZE_API_BASEURL + "random?minSize=".concat(minSize.toString(), "&maxSize=").concat(maxSize.toString()));\n            _context.next = 4;\n            return APIresponse;\n\n          case 4:\n            unparsed = _context.sent;\n            _context.next = 7;\n            return unparsed.json();\n\n          case 7:\n            parsed = _context.sent;\n            dims = parsed.map.length;\n            startpos = parsed.startingPosition.reverse();\n            endpos = parsed.endingPosition.reverse();\n            mazeMap = parsed.map;\n            createMaze(dims, dims);\n            maze.drawStart(startpos);\n            maze.drawEnd(endpos);\n\n            for (rowNum = 0; rowNum < mazeMap.length; rowNum++) {\n              row = mazeMap[rowNum];\n\n              for (colNum = 0; colNum < row.length; colNum++) {\n                cell = row[colNum];\n                if (cell === "X") maze.drawWall([rowNum, colNum]);\n              }\n            }\n\n            loadingPlaque.classList.add("invisible");\n\n          case 17:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _drawRandomMaze.apply(this, arguments);\n}\n\nalgoSelectElems.goButton.addEventListener("click", handleFindPath);\nvar execStartTime = -1;\n\nfunction handleFindPath() {\n  findPathUsingScript(algoSelectElems.algoSelect.value);\n}\n\nfunction findPathUsingScript(workerKey) {\n  if (!workerKey) return;\n  var worker = workers[workerKey].worker;\n  worker.addEventListener("message", function (e) {\n    if (e.data.length > 0) {\n      renderPerformanceInfo(e.data.length, Date.now());\n      maze.drawPath(e.data);\n    } else {\n      console.error("The algorithm didn\'t return a path");\n    }\n\n    loadingPlaque.classList.add("invisible");\n  });\n  var startPos = [maze.startCell.mazeRow, maze.startCell.mazeCol];\n  var endPos = [maze.endCell.mazeRow, maze.endCell.mazeCol];\n  execStartTime = Date.now();\n  loadingPlaque.classList.remove("invisible");\n  worker.postMessage({\n    dimensions: maze.dimensions,\n    start: startPos,\n    end: endPos,\n    walls: maze.walls\n  });\n}\n\nfunction renderPerformanceInfo(pathLength, execFinishTime) {\n  pathInfoElems.pathLenCaption.innerText = pathLength.toString();\n  pathInfoElems.execTimeCaption.innerText = (execFinishTime - execStartTime).toString() + " ms";\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc19tYXplZnJhbWV3b3JrLy4vc3JjL3V0aWxzLmpzPzAyNWUiLCJ3ZWJwYWNrOi8vanNfbWF6ZWZyYW1ld29yay8uL3NyYy9hbGdvcy9pbmRleC5qcz82NTk5Iiwid2VicGFjazovL2pzX21hemVmcmFtZXdvcmsvLi9zcmMvY29uc3RzLmpzP2ZiZDkiLCJ3ZWJwYWNrOi8vanNfbWF6ZWZyYW1ld29yay8uL3NyYy9pbmRleC5qcz9iNjM1Il0sIm5hbWVzIjpbImFkZE1vdXNlTGlzdGVuZXJzVG9DZWxsIiwiaHRtbENlbGwiLCJtYXplIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImN1cnBvcyIsIm1hemVSb3ciLCJtYXplQ29sIiwiYnV0dG9ucyIsInNoaWZ0S2V5IiwiZHJhd1N0YXJ0IiwiY3RybEtleSIsIm1ldGFLZXkiLCJkcmF3RW5kIiwiZHJhd1dhbGwiLCJlcmFzZUNlbGwiLCJnZXRDZWxsRGltZW5zaW9ucyIsImNvbHNOdW0iLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsInJlbW92ZUFsbENoaWxkcmVuIiwiZWxlbWVudCIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsIndvcmtlcnMiLCJhc3RhciIsIndvcmtlciIsIldvcmtlciIsIlVSTCIsImRpc3BsYXlOYW1lIiwibXJnZCIsIndhdmVfcHJvcGFnYXRpb24iLCJDRUxMX1RZUEVTIiwiRU1QVFkiLCJXQUxMIiwiU1RBUlQiLCJFTkQiLCJQQVRIIiwiQ0VMTF9UWVBFX1NUWUxFUyIsIlJBTkRPTV9NQVpFX0FQSV9CQVNFVVJMIiwiSFRNTFRhYmxlQ2VsbEVsZW1lbnQiLCJwcm90b3R5cGUiLCJjZWxsVHlwZSIsImNoYW5nZUNlbGxUeXBlVG8iLCJuZXdUeXBlIiwiY2xhc3NOYW1lIiwibWFpbk1hemVUYmwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJtYXplQ29udGFpbmVyIiwiZGltZW5zaW9uRWxlbXMiLCJyb3dJbnB1dCIsImNvbElucHV0IiwiZ29CdXR0b24iLCJyYW5kb21NYXplRWxlbXMiLCJtaW5TaXplU2VsZWN0IiwibWF4U2l6ZVNlbGVjdCIsImFsZ29TZWxlY3RFbGVtcyIsImFsZ29TZWxlY3QiLCJwYXRoSW5mb0VsZW1zIiwiZXJyb3JMYWJlbCIsInBhdGhMZW5DYXB0aW9uIiwiZXhlY1RpbWVDYXB0aW9uIiwibG9hZGluZ1BsYXF1ZSIsImhhbmRsZUNyZWF0ZU1hemUiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5Iiwia2V5Iiwid29ya2VySW5mbyIsIndvcmtlck9wdGlvbiIsImNyZWF0ZUVsZW1lbnQiLCJ2YWx1ZSIsImlubmVyVGV4dCIsImFwcGVuZCIsInJvd3NOdW0iLCJOdW1iZXIiLCJjcmVhdGVNYXplIiwicmVzZXRNYXplIiwiZGltZW5zaW9ucyIsInJvd051bWJlciIsImNvbE51bWJlciIsImNlbGxEaW1zIiwiY3VyUm93IiwiaHRtbFJvdyIsImluc2VydFJvdyIsImN1ckNlbGwiLCJpbnNlcnRDZWxsIiwic3R5bGUiLCJoZWlnaHQiLCJ3aWR0aCIsInB1c2giLCJjZWxscyIsIndhbGxzIiwicGF0aCIsInN0YXJ0Q2VsbCIsImVuZENlbGwiLCJkcmF3UGF0aCIsInBhdGhBcnJheSIsImNsZWFyUGF0aCIsInN0ZXAiLCJ0YXJnZXRDZWxsIiwiY29uc29sZSIsIndhcm4iLCJzaGlmdGVkIiwic2hpZnQiLCJwb3MiLCJmaWx0ZXIiLCJwYXRoQ2VsbCIsImNlbGwiLCJoYW5kbGVSYW5kb21NYXplIiwibWluU2l6ZSIsIm1heFNpemUiLCJkcmF3UmFuZG9tTWF6ZSIsImNsYXNzTGlzdCIsInJlbW92ZSIsIkFQSXJlc3BvbnNlIiwiZmV0Y2giLCJ0b1N0cmluZyIsInVucGFyc2VkIiwianNvbiIsInBhcnNlZCIsImRpbXMiLCJtYXAiLCJsZW5ndGgiLCJzdGFydHBvcyIsInN0YXJ0aW5nUG9zaXRpb24iLCJyZXZlcnNlIiwiZW5kcG9zIiwiZW5kaW5nUG9zaXRpb24iLCJtYXplTWFwIiwicm93TnVtIiwicm93IiwiY29sTnVtIiwiYWRkIiwiaGFuZGxlRmluZFBhdGgiLCJleGVjU3RhcnRUaW1lIiwiZmluZFBhdGhVc2luZ1NjcmlwdCIsIndvcmtlcktleSIsImRhdGEiLCJyZW5kZXJQZXJmb3JtYW5jZUluZm8iLCJEYXRlIiwibm93IiwiZXJyb3IiLCJzdGFydFBvcyIsImVuZFBvcyIsInBvc3RNZXNzYWdlIiwic3RhcnQiLCJlbmQiLCJwYXRoTGVuZ3RoIiwiZXhlY0ZpbmlzaFRpbWUiXSwibWFwcGluZ3MiOiI7O0FBQU8sU0FBU0EsdUJBQVQsQ0FBaUNDLFFBQWpDLEVBQTJDQyxJQUEzQyxFQUFpRDtBQUNwRDtBQUNBRCxVQUFRLENBQUNFLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDLFVBQVVDLENBQVYsRUFBYTtBQUNoREEsS0FBQyxDQUFDQyxjQUFGO0FBQ0EsUUFBTUMsTUFBTSxHQUFHLENBQUMsS0FBS0MsT0FBTixFQUFlLEtBQUtDLE9BQXBCLENBQWY7O0FBQ0EsUUFBSUosQ0FBQyxDQUFDSyxPQUFGLEtBQWMsQ0FBbEIsRUFBcUI7QUFDakIsVUFBSUwsQ0FBQyxDQUFDTSxRQUFOLEVBQWdCO0FBQ1pSLFlBQUksQ0FBQ1MsU0FBTCxDQUFlTCxNQUFmO0FBQ0gsT0FGRCxNQUVPLElBQUlGLENBQUMsQ0FBQ1EsT0FBRixJQUFhUixDQUFDLENBQUNTLE9BQW5CLEVBQTRCO0FBQy9CWCxZQUFJLENBQUNZLE9BQUwsQ0FBYVIsTUFBYjtBQUNILE9BRk0sTUFFQTtBQUNISixZQUFJLENBQUNhLFFBQUwsQ0FBY1QsTUFBZDtBQUNIO0FBQ0osS0FSRCxNQVFPLElBQUlGLENBQUMsQ0FBQ0ssT0FBRixLQUFjLENBQWxCLEVBQXFCO0FBQ3hCUCxVQUFJLENBQUNjLFNBQUwsQ0FBZVYsTUFBZjtBQUNIO0FBQ0osR0FkRCxFQUZvRCxDQWtCcEQ7QUFDQTs7QUFDQUwsVUFBUSxDQUFDRSxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxVQUFVQyxDQUFWLEVBQWE7QUFDNUNBLEtBQUMsQ0FBQ0MsY0FBRjtBQUNB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RixDQUFDLENBQUN5SSxJQUFoQjtBQUNILEtBSEQsTUFHTztBQUNIckMsYUFBTyxDQUFDeUMsS0FBUjtBQUNIOztBQUNEakYsaUJBQWEsQ0FBQ29ELFNBQWQsQ0FBd0JvQixHQUF4QixDQUE0QixXQUE1QjtBQUNILEdBUkQ7QUFVQSxNQUFNVSxRQUFRLEdBQUcsQ0FBQ2hKLElBQUksQ0FBQytGLFNBQUwsQ0FBZTFGLE9BQWhCLEVBQXlCTCxJQUFJLENBQUMrRixTQUFMLENBQWV6RixPQUF4QyxDQUFqQjtBQUNBLE1BQU0ySSxNQUFNLEdBQUcsQ0FBQ2pKLElBQUksQ0FBQ2dHLE9BQUwsQ0FBYTNGLE9BQWQsRUFBdUJMLElBQUksQ0FBQ2dHLE9BQUwsQ0FBYTFGLE9BQXBDLENBQWY7QUFDQWtJLGVBQWEsR0FBR0ssSUFBSSxDQUFDQyxHQUFMLEVBQWhCO0FBQ0FoRixlQUFhLENBQUNvRCxTQUFkLENBQXdCQyxNQUF4QixDQUErQixXQUEvQjtBQUNBMUYsUUFBTSxDQUFDeUgsV0FBUCxDQUFtQjtBQUNmbkUsY0FBVSxFQUFFL0UsSUFBSSxDQUFDK0UsVUFERjtBQUVmb0UsU0FBSyxFQUFFSCxRQUZRO0FBR2ZJLE9BQUcsRUFBRUgsTUFIVTtBQUlmcEQsU0FBSyxFQUFFN0YsSUFBSSxDQUFDNkY7QUFKRyxHQUFuQjtBQU1IOztBQUVELFNBQVMrQyxxQkFBVCxDQUErQlMsVUFBL0IsRUFBMkNDLGNBQTNDLEVBQTJEO0FBQ3ZENUYsZUFBYSxDQUFDRSxjQUFkLENBQTZCYSxTQUE3QixHQUF5QzRFLFVBQVUsQ0FBQy9CLFFBQVgsRUFBekM7QUFDQTVELGVBQWEsQ0FBQ0csZUFBZCxDQUE4QlksU0FBOUIsR0FDSSxDQUFDNkUsY0FBYyxHQUFHZCxhQUFsQixFQUFpQ2xCLFFBQWpDLEtBQThDLEtBRGxEO0FBRUgiLCJmaWxlIjoiMzY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFkZE1vdXNlTGlzdGVuZXJzVG9DZWxsKGh0bWxDZWxsLCBtYXplKSB7XG4gICAgLy8gcHJlc3MtZHJhZyBsaXN0ZW5lcnNcbiAgICBodG1sQ2VsbC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgY3VycG9zID0gW3RoaXMubWF6ZVJvdywgdGhpcy5tYXplQ29sXTtcbiAgICAgICAgaWYgKGUuYnV0dG9ucyA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBtYXplLmRyYXdTdGFydChjdXJwb3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgbWF6ZS5kcmF3RW5kKGN1cnBvcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hemUuZHJhd1dhbGwoY3VycG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlLmJ1dHRvbnMgPT09IDIpIHtcbiAgICAgICAgICAgIG1hemUuZXJhc2VDZWxsKGN1cnBvcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEZvciBzb21lIHJlYXNvbiwgc2luZ2xlIGNsaWNrcyBvdmVyIGNlbGxzIGFyZSBub3QgaGFuZGxlZCBieSBldmVudHMgYWJvdmUsXG4gICAgLy8gc28gd2UgaGF2ZSB0byB3cml0ZSB0aGVtIG91dCBzZXBhcmF0ZWx5XG4gICAgaHRtbENlbGwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgY3VycG9zID0gW3RoaXMubWF6ZVJvdywgdGhpcy5tYXplQ29sXTtcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIG1hemUuZHJhd1N0YXJ0KGN1cnBvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICAgICAgbWF6ZS5kcmF3RW5kKGN1cnBvcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXplLmRyYXdXYWxsKGN1cnBvcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBodG1sQ2VsbC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBjdXJwb3MgPSBbdGhpcy5tYXplUm93LCB0aGlzLm1hemVDb2xdO1xuICAgICAgICBtYXplLmVyYXNlQ2VsbChjdXJwb3MpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VsbERpbWVuc2lvbnMoY29sc051bSkge1xuICAgIHJldHVybiAod2luZG93LmlubmVySGVpZ2h0IC0gMjUpIC8gY29sc051bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbENoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG59IiwiZXhwb3J0IGNvbnN0IHdvcmtlcnMgPSB7XG4gICAgYXN0YXI6IHtcbiAgICAgICAgd29ya2VyOiBuZXcgV29ya2VyKG5ldyBVUkwoXCIuL3NjcmlwdHMvYXN0YXIuanNcIiwgaW1wb3J0Lm1ldGEudXJsKSksXG4gICAgICAgIGRpc3BsYXlOYW1lOiBcIkEqXCIsXG4gICAgfSxcbiAgICBtcmdkOiB7XG4gICAgICAgIHdvcmtlcjogbmV3IFdvcmtlcihuZXcgVVJMKFwiLi9zY3JpcHRzL21yZ2QuanNcIiwgaW1wb3J0Lm1ldGEudXJsKSksXG4gICAgICAgIGRpc3BsYXlOYW1lOiBcIk1SR0RcIixcbiAgICB9LFxuICAgIHdhdmVfcHJvcGFnYXRpb246IHtcbiAgICAgICAgd29ya2VyOiBuZXcgV29ya2VyKFxuICAgICAgICAgICAgbmV3IFVSTChcIi4vc2NyaXB0cy93YXZlX3Byb3BhZ2F0aW9uLmpzXCIsIGltcG9ydC5tZXRhLnVybClcbiAgICAgICAgKSxcbiAgICAgICAgZGlzcGxheU5hbWU6IFwiV2F2ZSBQcm9wYWdhdGlvblwiLFxuICAgIH0sXG59O1xuIiwiXG5leHBvcnQgY29uc3QgQ0VMTF9UWVBFUyA9IHtcbiAgICBFTVBUWTogMCxcbiAgICBXQUxMOiAxLFxuICAgIFNUQVJUOiAyLFxuICAgIEVORDogMyxcbiAgICBQQVRIOiA0LFxufTtcblxuZXhwb3J0IGNvbnN0IENFTExfVFlQRV9TVFlMRVMgPSB7XG4gICAgMDogXCJjZWxsLWVtcHR5XCIsIC8vIGVtcHR5XG4gICAgMTogXCJjZWxsLXdhbGxcIiwgLy8gd2FsbFxuICAgIDI6IFwiY2VsbC1zdGFydFwiLCAvLyBzdGFydFxuICAgIDM6IFwiY2VsbC1lbmRcIiwgLy8gZW5kXG4gICAgNDogXCJjZWxsLXBhdGhcIiwgLy8gcGF0aFxufTtcblxuZXhwb3J0IGNvbnN0IFJBTkRPTV9NQVpFX0FQSV9CQVNFVVJMID0gXCJodHRwczovL2FwaS5ub29wc2NoYWxsZW5nZS5jb20vbWF6ZWJvdC9cIjsiLCJpbXBvcnQgXCIuL3N0eWxlLmNzc1wiO1xuXG5pbXBvcnQge1xuICAgIGFkZE1vdXNlTGlzdGVuZXJzVG9DZWxsLFxuICAgIGdldENlbGxEaW1lbnNpb25zLFxuICAgIHJlbW92ZUFsbENoaWxkcmVuLFxufSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgd29ya2VycyB9IGZyb20gXCIuL2FsZ29zXCI7XG5pbXBvcnQgeyBDRUxMX1RZUEVTLCBDRUxMX1RZUEVfU1RZTEVTLCBSQU5ET01fTUFaRV9BUElfQkFTRVVSTCB9IGZyb20gXCIuL2NvbnN0c1wiO1xuXG5IVE1MVGFibGVDZWxsRWxlbWVudC5wcm90b3R5cGUuY2VsbFR5cGUgPSBDRUxMX1RZUEVTLkVNUFRZO1xuSFRNTFRhYmxlQ2VsbEVsZW1lbnQucHJvdG90eXBlLmNoYW5nZUNlbGxUeXBlVG8gPSBmdW5jdGlvbiAobmV3VHlwZSkge1xuICAgIHRoaXMuY2VsbFR5cGUgPSBuZXdUeXBlO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gQ0VMTF9UWVBFX1NUWUxFU1t0aGlzLmNlbGxUeXBlXTtcbn07XG5IVE1MVGFibGVDZWxsRWxlbWVudC5wcm90b3R5cGUubWF6ZVJvdyA9IDA7XG5IVE1MVGFibGVDZWxsRWxlbWVudC5wcm90b3R5cGUubWF6ZUNvbCA9IDA7XG5cbmNvbnN0IG1haW5NYXplVGJsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNtYXplLXRhYmxlXCIpO1xuY29uc3QgbWF6ZUNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubWF6ZS1jb250YWluZXJcIik7XG5cbm1haW5NYXplVGJsLmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSk7XG5cbmNvbnN0IGRpbWVuc2lvbkVsZW1zID0ge1xuICAgIHJvd0lucHV0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0LWRpbXMtcm93c1wiKSxcbiAgICBjb2xJbnB1dDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dC1kaW1zLWNvbHNcIiksXG4gICAgZ29CdXR0b246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZHJhdy1tYXplLWJ1dHRvblwiKSxcbn07XG5cbmNvbnN0IHJhbmRvbU1hemVFbGVtcyA9IHtcbiAgICBtaW5TaXplU2VsZWN0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3JhbmQtc2l6ZS1zZWxlY3QtbWluXCIpLFxuICAgIG1heFNpemVTZWxlY3Q6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcmFuZC1zaXplLXNlbGVjdC1tYXhcIiksXG4gICAgZ29CdXR0b246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcmFuZC1nZXQtbWF6ZVwiKSxcbn07XG5cbmNvbnN0IGFsZ29TZWxlY3RFbGVtcyA9IHtcbiAgICBhbGdvU2VsZWN0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2FsZ28tc2VsZWN0XCIpLFxuICAgIGdvQnV0dG9uOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2ZpbmQtcGF0aC1idXR0b25cIiksXG59O1xuXG5jb25zdCBwYXRoSW5mb0VsZW1zID0ge1xuICAgIGVycm9yTGFiZWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZXJyb3ItbGFiZWxcIiksXG4gICAgcGF0aExlbkNhcHRpb246IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcGF0aC1sZW5ndGhcIiksXG4gICAgZXhlY1RpbWVDYXB0aW9uOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2V4ZWMtdGltZVwiKSxcbn07XG5cbmNvbnN0IGxvYWRpbmdQbGFxdWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xvYWRpbmctcGxhcXVlXCIpO1xuXG4vLyBidXR0b24gZXZlbnRsaXN0ZW5lcnNcbmRpbWVuc2lvbkVsZW1zLmdvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDcmVhdGVNYXplKTtcblxuLy8gTWFpbiBwcm9ncmFtXG5sZXQgbWF6ZTtcblxuaGFuZGxlQ3JlYXRlTWF6ZSgpO1xuXG5PYmplY3QuZW50cmllcyh3b3JrZXJzKS5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IFtrZXksIHdvcmtlckluZm9dID0gZW50cnk7XG4gICAgY29uc3Qgd29ya2VyT3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICB3b3JrZXJPcHRpb24udmFsdWUgPSBrZXk7XG4gICAgd29ya2VyT3B0aW9uLmlubmVyVGV4dCA9IHdvcmtlckluZm8uZGlzcGxheU5hbWU7XG4gICAgYWxnb1NlbGVjdEVsZW1zLmFsZ29TZWxlY3QuYXBwZW5kKHdvcmtlck9wdGlvbik7XG59KTtcblxuZnVuY3Rpb24gaGFuZGxlQ3JlYXRlTWF6ZSgpIHtcbiAgICBsZXQgcm93c051bSA9IE51bWJlcihkaW1lbnNpb25FbGVtcy5yb3dJbnB1dC52YWx1ZSk7XG4gICAgbGV0IGNvbHNOdW0gPSBOdW1iZXIoZGltZW5zaW9uRWxlbXMuY29sSW5wdXQudmFsdWUpO1xuICAgIGNyZWF0ZU1hemUocm93c051bSwgY29sc051bSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hemUocm93c051bSwgY29sc051bSkge1xuICAgIG1hemUgPSByZXNldE1hemUoKTtcbiAgICByZW1vdmVBbGxDaGlsZHJlbihtYWluTWF6ZVRibCk7XG5cbiAgICBtYXplLmRpbWVuc2lvbnMucm93TnVtYmVyID0gcm93c051bTtcbiAgICBtYXplLmRpbWVuc2lvbnMuY29sTnVtYmVyID0gY29sc051bTtcblxuICAgIGNvbnN0IGNlbGxEaW1zID0gZ2V0Q2VsbERpbWVuc2lvbnMoY29sc051bSk7XG5cbiAgICBmb3IgKGxldCByb3dOdW1iZXIgPSAwOyByb3dOdW1iZXIgPCByb3dzTnVtOyByb3dOdW1iZXIrKykge1xuICAgICAgICBsZXQgY3VyUm93ID0gW107XG4gICAgICAgIGxldCBodG1sUm93ID0gbWFpbk1hemVUYmwuaW5zZXJ0Um93KHJvd051bWJlcik7XG4gICAgICAgIGZvciAobGV0IGNvbE51bWJlciA9IDA7IGNvbE51bWJlciA8IGNvbHNOdW07IGNvbE51bWJlcisrKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gSFRNTCBjZWxsXG4gICAgICAgICAgICBsZXQgY3VyQ2VsbCA9IGh0bWxSb3cuaW5zZXJ0Q2VsbChjb2xOdW1iZXIpO1xuICAgICAgICAgICAgY3VyQ2VsbC5tYXplUm93ID0gcm93TnVtYmVyO1xuICAgICAgICAgICAgY3VyQ2VsbC5tYXplQ29sID0gY29sTnVtYmVyO1xuXG4gICAgICAgICAgICBjdXJDZWxsLnN0eWxlLmhlaWdodCA9IGNlbGxEaW1zICsgXCJweFwiO1xuICAgICAgICAgICAgY3VyQ2VsbC5zdHlsZS53aWR0aCA9IGNlbGxEaW1zICsgXCJweFwiO1xuXG4gICAgICAgICAgICBhZGRNb3VzZUxpc3RlbmVyc1RvQ2VsbChjdXJDZWxsLCBtYXplKTtcbiAgICAgICAgICAgIGN1clJvdy5wdXNoKGN1ckNlbGwpO1xuICAgICAgICB9XG4gICAgICAgIG1hemUuY2VsbHMucHVzaChjdXJSb3cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRNYXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgIHJvd051bWJlcjogMCxcbiAgICAgICAgICAgIGNvbE51bWJlcjogMCxcbiAgICAgICAgfSxcbiAgICAgICAgY2VsbHM6IFtdLFxuICAgICAgICB3YWxsczogW10sXG4gICAgICAgIHBhdGg6IFtdLFxuICAgICAgICBzdGFydENlbGw6IG51bGwsXG4gICAgICAgIGVuZENlbGw6IG51bGwsXG4gICAgICAgIGRyYXdQYXRoOiBmdW5jdGlvbiAocGF0aEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGF0aCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RlcCBvZiBwYXRoQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0Q2VsbCA9IHRoaXMuY2VsbHNbc3RlcFswXV1bc3RlcFsxXV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldENlbGwuY2VsbFR5cGUgPT09IENFTExfVFlQRVMuRU1QVFkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VsbC5jaGFuZ2VDZWxsVHlwZVRvKENFTExfVFlQRVMuUEFUSCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aC5wdXNoKHRhcmdldENlbGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTa2lwcGluZyBwYXRoIGF0ICR7c3RlcFswXX0sICR7c3RlcFsxXX0gYmVjYXVzZSBpdCdzIG5vdCBhbiBlbXB0eSBjZWxsLmBcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyUGF0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IHNoaWZ0ZWQgPSB0aGlzLnBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIHdoaWxlIChzaGlmdGVkKSB7XG4gICAgICAgICAgICAgICAgc2hpZnRlZC5jaGFuZ2VDZWxsVHlwZVRvKENFTExfVFlQRVMuRU1QVFkpO1xuICAgICAgICAgICAgICAgIHNoaWZ0ZWQgPSB0aGlzLnBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZHJhd1dhbGw6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRDZWxsID0gdGhpcy5jZWxsc1twb3NbMF1dW3Bvc1sxXV07XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2VsbC5jZWxsVHlwZSA9PT0gQ0VMTF9UWVBFUy5TVEFSVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDZWxsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRDZWxsLmNlbGxUeXBlID09PSBDRUxMX1RZUEVTLkVORCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2VsbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2VsbC5jZWxsVHlwZSA9PT0gQ0VMTF9UWVBFUy5QQVRIKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gdGhpcy5wYXRoLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKHBhdGhDZWxsKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ2VsbC5tYXplUm93ID09PSB0YXJnZXRDZWxsLm1hemVSb3cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoQ2VsbC5tYXplQ29sID09PSB0YXJnZXRDZWxsLm1hemVDb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0Q2VsbC5jaGFuZ2VDZWxsVHlwZVRvKENFTExfVFlQRVMuV0FMTCk7XG4gICAgICAgICAgICB0aGlzLndhbGxzLnB1c2goW3RhcmdldENlbGwubWF6ZVJvdywgdGFyZ2V0Q2VsbC5tYXplQ29sXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdTdGFydDogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgbGV0IHRhcmdldENlbGwgPSB0aGlzLmNlbGxzW3Bvc1swXV1bcG9zWzFdXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0Q2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDZWxsLmNoYW5nZUNlbGxUeXBlVG8oQ0VMTF9UWVBFUy5FTVBUWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0YXJnZXRDZWxsLmNoYW5nZUNlbGxUeXBlVG8oQ0VMTF9UWVBFUy5TVEFSVCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Q2VsbCA9IHRhcmdldENlbGw7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYXdFbmQ6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRDZWxsID0gdGhpcy5jZWxsc1twb3NbMF1dW3Bvc1sxXV07XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRDZWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDZWxsLmNoYW5nZUNlbGxUeXBlVG8oQ0VMTF9UWVBFUy5FTVBUWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbCkgdGFyZ2V0Q2VsbC5jaGFuZ2VDZWxsVHlwZVRvKENFTExfVFlQRVMuRU5EKTtcbiAgICAgICAgICAgIHRoaXMuZW5kQ2VsbCA9IHRhcmdldENlbGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVyYXNlQ2VsbDogZnVuY3Rpb24gKHBvcykge1xuICAgICAgICAgICAgbGV0IHRhcmdldENlbGwgPSB0aGlzLmNlbGxzW3Bvc1swXV1bcG9zWzFdXTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRDZWxsLmNlbGxUeXBlICE9PSBDRUxMX1RZUEVTLkVNUFRZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldENlbGwuY2VsbFR5cGUgPT09IENFTExfVFlQRVMuU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENlbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q2VsbC5jZWxsVHlwZSA9PT0gQ0VMTF9UWVBFUy5FTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDZWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2VsbC5jaGFuZ2VDZWxsVHlwZVRvKENFTExfVFlQRVMuRU1QVFkpO1xuICAgICAgICAgICAgICAgIG1hemUud2FsbHMgPSBtYXplLndhbGxzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgKGNlbGwpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbMF0gPT09IHRhcmdldENlbGwubWF6ZVJvdyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxbMV0gPT09IHRhcmdldENlbGwubWF6ZUNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuLy8jcmVnaW9uIHJhbmRvbSBtYXplIGxvZ2ljXG5yYW5kb21NYXplRWxlbXMuZ29CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZVJhbmRvbU1hemUpO1xuXG5mdW5jdGlvbiBoYW5kbGVSYW5kb21NYXplKCkge1xuICAgIGxldCBtaW5TaXplID0gTnVtYmVyKHJhbmRvbU1hemVFbGVtcy5taW5TaXplU2VsZWN0LnZhbHVlKTtcbiAgICBsZXQgbWF4U2l6ZSA9IE51bWJlcihyYW5kb21NYXplRWxlbXMubWF4U2l6ZVNlbGVjdC52YWx1ZSk7XG4gICAgaWYgKG1heFNpemUgPCBtaW5TaXplKSBtYXhTaXplID0gbWluU2l6ZTtcblxuICAgIGRyYXdSYW5kb21NYXplKG1pblNpemUsIG1heFNpemUpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkcmF3UmFuZG9tTWF6ZShtaW5TaXplLCBtYXhTaXplKSB7XG4gICAgbG9hZGluZ1BsYXF1ZS5jbGFzc0xpc3QucmVtb3ZlKFwiaW52aXNpYmxlXCIpO1xuICAgIGxldCBBUElyZXNwb25zZSA9IGZldGNoKFxuICAgICAgICBSQU5ET01fTUFaRV9BUElfQkFTRVVSTCArXG4gICAgICAgICAgICBgcmFuZG9tP21pblNpemU9JHttaW5TaXplLnRvU3RyaW5nKCl9Jm1heFNpemU9JHttYXhTaXplLnRvU3RyaW5nKCl9YFxuICAgICk7XG4gICAgbGV0IHVucGFyc2VkID0gYXdhaXQgQVBJcmVzcG9uc2U7XG4gICAgbGV0IHBhcnNlZCA9IGF3YWl0IHVucGFyc2VkLmpzb24oKTtcblxuICAgIGxldCBkaW1zID0gcGFyc2VkLm1hcC5sZW5ndGg7XG4gICAgbGV0IHN0YXJ0cG9zID0gcGFyc2VkLnN0YXJ0aW5nUG9zaXRpb24ucmV2ZXJzZSgpO1xuICAgIGxldCBlbmRwb3MgPSBwYXJzZWQuZW5kaW5nUG9zaXRpb24ucmV2ZXJzZSgpO1xuICAgIGxldCBtYXplTWFwID0gcGFyc2VkLm1hcDtcblxuICAgIGNyZWF0ZU1hemUoZGltcywgZGltcyk7XG4gICAgbWF6ZS5kcmF3U3RhcnQoc3RhcnRwb3MpO1xuICAgIG1hemUuZHJhd0VuZChlbmRwb3MpO1xuXG4gICAgZm9yIChsZXQgcm93TnVtID0gMDsgcm93TnVtIDwgbWF6ZU1hcC5sZW5ndGg7IHJvd051bSsrKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IG1hemVNYXBbcm93TnVtXTtcbiAgICAgICAgZm9yIChsZXQgY29sTnVtID0gMDsgY29sTnVtIDwgcm93Lmxlbmd0aDsgY29sTnVtKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSByb3dbY29sTnVtXTtcbiAgICAgICAgICAgIGlmIChjZWxsID09PSBcIlhcIikgbWF6ZS5kcmF3V2FsbChbcm93TnVtLCBjb2xOdW1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkaW5nUGxhcXVlLmNsYXNzTGlzdC5hZGQoXCJpbnZpc2libGVcIik7XG59XG4vLyNlbmRyZWdpb25cblxuLy8gcGF0aGZpbmRpbmcgYWxnb3JpdGhtcyBjb25uZWN0aW9uIGxvZ2ljXG5cbmFsZ29TZWxlY3RFbGVtcy5nb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlRmluZFBhdGgpO1xubGV0IGV4ZWNTdGFydFRpbWUgPSAtMTtcbmZ1bmN0aW9uIGhhbmRsZUZpbmRQYXRoKCkge1xuICAgIGZpbmRQYXRoVXNpbmdTY3JpcHQoYWxnb1NlbGVjdEVsZW1zLmFsZ29TZWxlY3QudmFsdWUpO1xufVxuXG5mdW5jdGlvbiBmaW5kUGF0aFVzaW5nU2NyaXB0KHdvcmtlcktleSkge1xuICAgIGlmICghd29ya2VyS2V5KSByZXR1cm47XG4gICAgbGV0IHdvcmtlciA9IHdvcmtlcnNbd29ya2VyS2V5XS53b3JrZXI7XG5cbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKGUpID0+IHtcbiAgICAgICAgaWYgKGUuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZW5kZXJQZXJmb3JtYW5jZUluZm8oZS5kYXRhLmxlbmd0aCwgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICBtYXplLmRyYXdQYXRoKGUuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgYWxnb3JpdGhtIGRpZG4ndCByZXR1cm4gYSBwYXRoYCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGluZ1BsYXF1ZS5jbGFzc0xpc3QuYWRkKFwiaW52aXNpYmxlXCIpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3RhcnRQb3MgPSBbbWF6ZS5zdGFydENlbGwubWF6ZVJvdywgbWF6ZS5zdGFydENlbGwubWF6ZUNvbF07XG4gICAgY29uc3QgZW5kUG9zID0gW21hemUuZW5kQ2VsbC5tYXplUm93LCBtYXplLmVuZENlbGwubWF6ZUNvbF07XG4gICAgZXhlY1N0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbG9hZGluZ1BsYXF1ZS5jbGFzc0xpc3QucmVtb3ZlKFwiaW52aXNpYmxlXCIpO1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGRpbWVuc2lvbnM6IG1hemUuZGltZW5zaW9ucyxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0UG9zLFxuICAgICAgICBlbmQ6IGVuZFBvcyxcbiAgICAgICAgd2FsbHM6IG1hemUud2FsbHMsXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclBlcmZvcm1hbmNlSW5mbyhwYXRoTGVuZ3RoLCBleGVjRmluaXNoVGltZSkge1xuICAgIHBhdGhJbmZvRWxlbXMucGF0aExlbkNhcHRpb24uaW5uZXJUZXh0ID0gcGF0aExlbmd0aC50b1N0cmluZygpO1xuICAgIHBhdGhJbmZvRWxlbXMuZXhlY1RpbWVDYXB0aW9uLmlubmVyVGV4dCA9XG4gICAgICAgIChleGVjRmluaXNoVGltZSAtIGV4ZWNTdGFydFRpbWUpLnRvU3RyaW5nKCkgKyBcIiBtc1wiO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///367\n')}},__webpack_require__={};__webpack_require__.m=__webpack_modules__,__webpack_require__.u=Q=>Q+".bundle.js",__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(Q){if("object"==typeof window)return window}}(),__webpack_require__.o=(Q,F)=>Object.prototype.hasOwnProperty.call(Q,F),(()=>{var Q;__webpack_require__.g.importScripts&&(Q=__webpack_require__.g.location+"");var F=__webpack_require__.g.document;if(!Q&&F&&(F.currentScript&&(Q=F.currentScript.src),!Q)){var U=F.getElementsByTagName("script");U.length&&(Q=U[U.length-1].src)}if(!Q)throw new Error("Automatic publicPath is not supported in this browser");Q=Q.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=Q})(),__webpack_require__.b=document.baseURI||self.location.href;var __webpack_exports__={};__webpack_modules__[367](0,__webpack_exports__,__webpack_require__)})();