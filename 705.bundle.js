(()=>{var __webpack_modules__={705:()=>{eval('function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n// worker eventlistener. Do not change this.\n//#region\nself.addEventListener("message", function (e) {\n  self.postMessage(solve(e.data));\n}); //#endregion\n// your code goes below this line\n// ----------------------------------------------------------\n// Author: Aleksandr Kozlov (https://github.com/mr9d/)\n\nfunction createMaze(mazeInfo) {\n  var maze = new Array(mazeInfo.dimensions.rowNumber).fill([]);\n  maze = maze.map(function (_) {\n    return new Array(mazeInfo.dimensions.colNumber).fill(" ");\n  });\n  maze[mazeInfo.start[0]][mazeInfo.start[1]] = "s";\n  maze[mazeInfo.end[0]][mazeInfo.end[1]] = "e";\n  mazeInfo.walls.forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        row = _ref2[0],\n        col = _ref2[1];\n\n    return maze[row][col] = "#";\n  });\n  return maze;\n}\n\nfunction cloneMaze(maze) {\n  var newMaze = [];\n  maze.forEach(function (row) {\n    newMaze.push(_toConsumableArray(row));\n  });\n  return newMaze;\n}\n\nfunction consoleMaze(maze) {\n  for (var row = 0; row < maze.length; row++) {\n    console.log(maze[row].join(""));\n  }\n}\n\nfunction checkRowCol(row, col, mazeInfo) {\n  return row >= 0 && col >= 0 && row < mazeInfo.dimensions.rowNumber && col < mazeInfo.dimensions.colNumber;\n}\n\nfunction getNearCells(row, col, mazeInfo) {\n  return [[row + 1, col], [row - 1, col], [row, col + 1], [row, col - 1]].filter(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        r = _ref4[0],\n        c = _ref4[1];\n\n    return checkRowCol(r, c, mazeInfo);\n  });\n}\n\nfunction hasWeight(row, col, maze) {\n  return maze[row][col] === "e" || +maze[row][col] > 0;\n}\n\nfunction getWeight(row, col, maze) {\n  if (maze[row][col] === "e") {\n    return 0;\n  }\n\n  if (+maze[row][col] > 0) {\n    return +maze[row][col];\n  }\n\n  return null;\n}\n\nfunction solve(mazeInfo) {\n  // main solve function\n  // â€‹\n  // mazeInfo is a JS object and it contains the following info:\n  // dimensions: Object { rowNumber: 278, colNumber: 165 } -- the number of rows and cols\n  // end: Array [ 180, 79 ] -- the coordinates of the end\n  // start: Array [ 142, 79 ] -- the coordinates of the start\n  // walls: [[0,1], [0,2]] -- array of coordinates of the walls\n  // this function must return an array of coordinates of the path (similar to the walls)\n  // Happy pathfinding! :)\n  // console.log(mazeInfo);\n  // console.log(mazeInfo.dimensions);\n  // console.log("start", mazeInfo.start);\n  // console.log("end", mazeInfo.end);\n  // console.log(mazeInfo.walls);\n  var maze = createMaze(mazeInfo); // calculating weights\n\n  var finished = false;\n\n  while (!finished) {\n    var nextStepMaze = cloneMaze(maze);\n    var cellUpdateCount = 0;\n\n    for (var row = 0; row < mazeInfo.dimensions.rowNumber; row++) {\n      for (var col = 0; col < mazeInfo.dimensions.colNumber; col++) {\n        if (maze[row][col] === " ") {\n          var nearCells = getNearCells(row, col, mazeInfo);\n          var withWeight = nearCells.filter(function (_ref5) {\n            var _ref6 = _slicedToArray(_ref5, 2),\n                r = _ref6[0],\n                c = _ref6[1];\n\n            return hasWeight(r, c, maze);\n          });\n\n          if (withWeight.length > 0) {\n            var maxWeight = withWeight.map(function (_ref7) {\n              var _ref8 = _slicedToArray(_ref7, 2),\n                  r = _ref8[0],\n                  c = _ref8[1];\n\n              return getWeight(r, c, maze);\n            }).reduce(function (a, b) {\n              return Math.max(a, b);\n            });\n            nextStepMaze[row][col] = maxWeight + 1;\n            cellUpdateCount++;\n          }\n        }\n      }\n    }\n\n    maze = nextStepMaze;\n    finished = cellUpdateCount === 0;\n  } // looking for path based on weights\n\n\n  var path = [];\n  var coord = mazeInfo.start;\n\n  while (coord[0] !== mazeInfo.end[0] || coord[1] !== mazeInfo.end[1]) {\n    path.push(coord);\n\n    var _nearCells = getNearCells(coord[0], coord[1], mazeInfo);\n\n    var _withWeight = _nearCells.filter(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n          r = _ref10[0],\n          c = _ref10[1];\n\n      return hasWeight(r, c, maze);\n    });\n\n    if (_withWeight.length === 0) {\n      // throw error?\n      break;\n    }\n\n    var cellWithMinWeight = _withWeight.reduce(function (a, b) {\n      return getWeight(a[0], a[1], maze) > getWeight(b[0], b[1], maze) ? b : a;\n    });\n\n    coord = cellWithMinWeight;\n  }\n\n  path.push(coord); //consoleMaze(maze);\n  //console.log(path);\n\n  return path;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qc19tYXplZnJhbWV3b3JrLy4vc3JjL2FsZ29zL3NjcmlwdHMvbXJnZC5qcz82MGViIl0sIm5hbWVzIjpbInNlbGYiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInBvc3RNZXNzYWdlIiwic29sdmUiLCJkYXRhIiwiY3JlYXRlTWF6ZSIsIm1hemVJbmZvIiwibWF6ZSIsIkFycmF5IiwiZGltZW5zaW9ucyIsInJvd051bWJlciIsImZpbGwiLCJtYXAiLCJfIiwiY29sTnVtYmVyIiwic3RhcnQiLCJlbmQiLCJ3YWxscyIsImZvckVhY2giLCJyb3ciLCJjb2wiLCJjbG9uZU1hemUiLCJuZXdNYXplIiwicHVzaCIsImNvbnNvbGVNYXplIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsImpvaW4iLCJjaGVja1Jvd0NvbCIsImdldE5lYXJDZWxscyIsImZpbHRlciIsInIiLCJjIiwiaGFzV2VpZ2h0IiwiZ2V0V2VpZ2h0IiwiZmluaXNoZWQiLCJuZXh0U3RlcE1hemUiLCJjZWxsVXBkYXRlQ291bnQiLCJuZWFyQ2VsbHMiLCJ3aXRoV2VpZ2h0IiwibWF4V2VpZ2h0IiwicmVkdWNlIiwiYSIsImIiLCJNYXRoIiwibWF4IiwicGF0aCIsImNvb3JkIiwiY2VsbFdpdGhNaW5XZWlnaHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBQSxJQUFJLENBQUNDLGdCQUFMLENBQXNCLFNBQXRCLEVBQWlDLFVBQUNDLENBQUQsRUFBTztBQUNwQ0YsRUFBQUEsSUFBSSxDQUFDRyxXQUFMLENBQWlCQyxLQUFLLENBQUNGLENBQUMsQ0FBQ0csSUFBSCxDQUF0QjtBQUNILENBRkQsRSxDQUdBO0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVNDLFVBQVQsQ0FBb0JDLFFBQXBCLEVBQThCO0FBQzFCLE1BQUlDLElBQUksR0FBRyxJQUFJQyxLQUFKLENBQVVGLFFBQVEsQ0FBQ0csVUFBVCxDQUFvQkMsU0FBOUIsRUFBeUNDLElBQXpD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QU1ULFVBQVMsR0FBR1QsWUFBWSxDQUFDa0IsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXQSxLQUFLLENBQUMsQ0FBRCxDQUFoQixFQUFxQjFDLFFBQXJCLENBQTlCOztBQUNBLFFBQU1rQyxXQUFVLEdBQUdELFVBQVMsQ0FBQ1IsTUFBVixDQUFpQjtBQUFBO0FBQUEsVUFBRUMsQ0FBRjtBQUFBLFVBQUtDLENBQUw7O0FBQUEsYUFBWUMsU0FBUyxDQUFDRixDQUFELEVBQUlDLENBQUosRUFBTzFCLElBQVAsQ0FBckI7QUFBQSxLQUFqQixDQUFuQjs7QUFDQSxRQUFJaUMsV0FBVSxDQUFDZixNQUFYLEtBQXNCLENBQTFCLEVBQTZCO0FBQ3pCO0FBQ0E7QUFDSDs7QUFDRCxRQUFNd0IsaUJBQWlCLEdBQUdULFdBQVUsQ0FBQ0UsTUFBWCxDQUFrQixVQUFDQyxDQUFELEVBQUlDLENBQUo7QUFBQSxhQUN4Q1QsU0FBUyxDQUFDUSxDQUFDLENBQUMsQ0FBRCxDQUFGLEVBQU9BLENBQUMsQ0FBQyxDQUFELENBQVIsRUFBYXBDLElBQWIsQ0FBVCxHQUE4QjRCLFNBQVMsQ0FBQ1MsQ0FBQyxDQUFDLENBQUQsQ0FBRixFQUFPQSxDQUFDLENBQUMsQ0FBRCxDQUFSLEVBQWFyQyxJQUFiLENBQXZDLEdBQTREcUMsQ0FBNUQsR0FBZ0VELENBRHhCO0FBQUEsS0FBbEIsQ0FBMUI7O0FBR0FLLElBQUFBLEtBQUssR0FBR0MsaUJBQVI7QUFDSDs7QUFDREYsRUFBQUEsSUFBSSxDQUFDeEIsSUFBTCxDQUFVeUIsS0FBVixFQWhFcUIsQ0FrRXJCO0FBQ0E7O0FBRUEsU0FBT0QsSUFBUDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiLy8gd29ya2VyIGV2ZW50bGlzdGVuZXIuIERvIG5vdCBjaGFuZ2UgdGhpcy5cbi8vI3JlZ2lvblxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoc29sdmUoZS5kYXRhKSk7XG59KTtcbi8vI2VuZHJlZ2lvblxuXG4vLyB5b3VyIGNvZGUgZ29lcyBiZWxvdyB0aGlzIGxpbmVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEF1dGhvcjogQWxla3NhbmRyIEtvemxvdiAoaHR0cHM6Ly9naXRodWIuY29tL21yOWQvKVxuXG5mdW5jdGlvbiBjcmVhdGVNYXplKG1hemVJbmZvKSB7XG4gICAgbGV0IG1hemUgPSBuZXcgQXJyYXkobWF6ZUluZm8uZGltZW5zaW9ucy5yb3dOdW1iZXIpLmZpbGwoW10pO1xuICAgIG1hemUgPSBtYXplLm1hcCgoXykgPT4gbmV3IEFycmF5KG1hemVJbmZvLmRpbWVuc2lvbnMuY29sTnVtYmVyKS5maWxsKFwiIFwiKSk7XG5cbiAgICBtYXplW21hemVJbmZvLnN0YXJ0WzBdXVttYXplSW5mby5zdGFydFsxXV0gPSBcInNcIjtcbiAgICBtYXplW21hemVJbmZvLmVuZFswXV1bbWF6ZUluZm8uZW5kWzFdXSA9IFwiZVwiO1xuICAgIG1hemVJbmZvLndhbGxzLmZvckVhY2goKFtyb3csIGNvbF0pID0+IChtYXplW3Jvd11bY29sXSA9IFwiI1wiKSk7XG5cbiAgICByZXR1cm4gbWF6ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVNYXplKG1hemUpIHtcbiAgICBjb25zdCBuZXdNYXplID0gW107XG4gICAgbWF6ZS5mb3JFYWNoKChyb3cpID0+IHtcbiAgICAgICAgbmV3TWF6ZS5wdXNoKFsuLi5yb3ddKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3TWF6ZTtcbn1cblxuZnVuY3Rpb24gY29uc29sZU1hemUobWF6ZSkge1xuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hemUubGVuZ3RoOyByb3crKykge1xuICAgICAgICBjb25zb2xlLmxvZyhtYXplW3Jvd10uam9pbihcIlwiKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Jvd0NvbChyb3csIGNvbCwgbWF6ZUluZm8pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICByb3cgPj0gMCAmJlxuICAgICAgICBjb2wgPj0gMCAmJlxuICAgICAgICByb3cgPCBtYXplSW5mby5kaW1lbnNpb25zLnJvd051bWJlciAmJlxuICAgICAgICBjb2wgPCBtYXplSW5mby5kaW1lbnNpb25zLmNvbE51bWJlclxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJDZWxscyhyb3csIGNvbCwgbWF6ZUluZm8pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBbcm93ICsgMSwgY29sXSxcbiAgICAgICAgW3JvdyAtIDEsIGNvbF0sXG4gICAgICAgIFtyb3csIGNvbCArIDFdLFxuICAgICAgICBbcm93LCBjb2wgLSAxXSxcbiAgICBdLmZpbHRlcigoW3IsIGNdKSA9PiBjaGVja1Jvd0NvbChyLCBjLCBtYXplSW5mbykpO1xufVxuXG5mdW5jdGlvbiBoYXNXZWlnaHQocm93LCBjb2wsIG1hemUpIHtcbiAgICByZXR1cm4gbWF6ZVtyb3ddW2NvbF0gPT09IFwiZVwiIHx8ICttYXplW3Jvd11bY29sXSA+IDA7XG59XG5cbmZ1bmN0aW9uIGdldFdlaWdodChyb3csIGNvbCwgbWF6ZSkge1xuICAgIGlmIChtYXplW3Jvd11bY29sXSA9PT0gXCJlXCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICgrbWF6ZVtyb3ddW2NvbF0gPiAwKSB7XG4gICAgICAgIHJldHVybiArbWF6ZVtyb3ddW2NvbF07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzb2x2ZShtYXplSW5mbykge1xuICAgIC8vIG1haW4gc29sdmUgZnVuY3Rpb25cbiAgICAvLyDigItcbiAgICAvLyBtYXplSW5mbyBpcyBhIEpTIG9iamVjdCBhbmQgaXQgY29udGFpbnMgdGhlIGZvbGxvd2luZyBpbmZvOlxuICAgIC8vIGRpbWVuc2lvbnM6IE9iamVjdCB7IHJvd051bWJlcjogMjc4LCBjb2xOdW1iZXI6IDE2NSB9IC0tIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sc1xuICAgIC8vIGVuZDogQXJyYXkgWyAxODAsIDc5IF0gLS0gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBlbmRcbiAgICAvLyBzdGFydDogQXJyYXkgWyAxNDIsIDc5IF0gLS0gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzdGFydFxuICAgIC8vIHdhbGxzOiBbWzAsMV0sIFswLDJdXSAtLSBhcnJheSBvZiBjb29yZGluYXRlcyBvZiB0aGUgd2FsbHNcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMgb2YgdGhlIHBhdGggKHNpbWlsYXIgdG8gdGhlIHdhbGxzKVxuICAgIC8vIEhhcHB5IHBhdGhmaW5kaW5nISA6KVxuXG4gICAgLy8gY29uc29sZS5sb2cobWF6ZUluZm8pO1xuICAgIC8vIGNvbnNvbGUubG9nKG1hemVJbmZvLmRpbWVuc2lvbnMpO1xuICAgIC8vIGNvbnNvbGUubG9nKFwic3RhcnRcIiwgbWF6ZUluZm8uc3RhcnQpO1xuICAgIC8vIGNvbnNvbGUubG9nKFwiZW5kXCIsIG1hemVJbmZvLmVuZCk7XG4gICAgLy8gY29uc29sZS5sb2cobWF6ZUluZm8ud2FsbHMpO1xuXG4gICAgbGV0IG1hemUgPSBjcmVhdGVNYXplKG1hemVJbmZvKTtcblxuICAgIC8vIGNhbGN1bGF0aW5nIHdlaWdodHNcbiAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICB3aGlsZSAoIWZpbmlzaGVkKSB7XG4gICAgICAgIGNvbnN0IG5leHRTdGVwTWF6ZSA9IGNsb25lTWF6ZShtYXplKTtcbiAgICAgICAgbGV0IGNlbGxVcGRhdGVDb3VudCA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbWF6ZUluZm8uZGltZW5zaW9ucy5yb3dOdW1iZXI7IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBtYXplSW5mby5kaW1lbnNpb25zLmNvbE51bWJlcjsgY29sKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWF6ZVtyb3ddW2NvbF0gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lYXJDZWxscyA9IGdldE5lYXJDZWxscyhyb3csIGNvbCwgbWF6ZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aXRoV2VpZ2h0ID0gbmVhckNlbGxzLmZpbHRlcigoW3IsIGNdKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzV2VpZ2h0KHIsIGMsIG1hemUpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aXRoV2VpZ2h0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFdlaWdodCA9IHdpdGhXZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChbciwgY10pID0+IGdldFdlaWdodChyLCBjLCBtYXplKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBNYXRoLm1heChhLCBiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RlcE1hemVbcm93XVtjb2xdID0gbWF4V2VpZ2h0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxVcGRhdGVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWF6ZSA9IG5leHRTdGVwTWF6ZTtcbiAgICAgICAgZmluaXNoZWQgPSBjZWxsVXBkYXRlQ291bnQgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gbG9va2luZyBmb3IgcGF0aCBiYXNlZCBvbiB3ZWlnaHRzXG4gICAgbGV0IHBhdGggPSBbXTtcbiAgICBsZXQgY29vcmQgPSBtYXplSW5mby5zdGFydDtcbiAgICB3aGlsZSAoY29vcmRbMF0gIT09IG1hemVJbmZvLmVuZFswXSB8fCBjb29yZFsxXSAhPT0gbWF6ZUluZm8uZW5kWzFdKSB7XG4gICAgICAgIHBhdGgucHVzaChjb29yZCk7XG4gICAgICAgIGNvbnN0IG5lYXJDZWxscyA9IGdldE5lYXJDZWxscyhjb29yZFswXSwgY29vcmRbMV0sIG1hemVJbmZvKTtcbiAgICAgICAgY29uc3Qgd2l0aFdlaWdodCA9IG5lYXJDZWxscy5maWx0ZXIoKFtyLCBjXSkgPT4gaGFzV2VpZ2h0KHIsIGMsIG1hemUpKTtcbiAgICAgICAgaWYgKHdpdGhXZWlnaHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvcj9cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGxXaXRoTWluV2VpZ2h0ID0gd2l0aFdlaWdodC5yZWR1Y2UoKGEsIGIpID0+XG4gICAgICAgICAgICBnZXRXZWlnaHQoYVswXSwgYVsxXSwgbWF6ZSkgPiBnZXRXZWlnaHQoYlswXSwgYlsxXSwgbWF6ZSkgPyBiIDogYVxuICAgICAgICApO1xuICAgICAgICBjb29yZCA9IGNlbGxXaXRoTWluV2VpZ2h0O1xuICAgIH1cbiAgICBwYXRoLnB1c2goY29vcmQpO1xuXG4gICAgLy9jb25zb2xlTWF6ZShtYXplKTtcbiAgICAvL2NvbnNvbGUubG9nKHBhdGgpO1xuXG4gICAgcmV0dXJuIHBhdGg7XG59XG4iXSwiZmlsZSI6IjcwNS5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///705\n')}},__webpack_exports__={};__webpack_modules__[705]()})();